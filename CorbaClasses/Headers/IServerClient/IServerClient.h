// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.3

#ifndef ___IServerClient_h__
#define ___IServerClient_h__

#include <domaindata.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030300L)
#       error ORBacus version mismatch!
#   endif
#endif

class IServerClient;
typedef IServerClient* IServerClient_ptr;
typedef IServerClient* IServerClientRef;

extern OB::TypeCodeConst _tc_IServerClient;

void OBDuplicate(IServerClient_ptr);
void OBRelease(IServerClient_ptr);

void OBMarshal(IServerClient_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(IServerClient_ptr&, OB::InputStreamImpl*);

typedef OB::ObjVar< IServerClient > IServerClient_var;
typedef OB::ObjOut< IServerClient > IServerClient_out;

class OBStubImpl_IServerClient;
typedef OBStubImpl_IServerClient* OBStubImpl_IServerClient_ptr;

void OBDuplicate(OBStubImpl_IServerClient_ptr);
void OBRelease(OBStubImpl_IServerClient_ptr);

typedef OB::ObjVar< OBStubImpl_IServerClient > OBStubImpl_IServerClient_var;

//
// IDL:IServerClient:1.0
//
class IServerClient : virtual public ::CORBA::Object
{
    IServerClient(const IServerClient&);
    void operator=(const IServerClient&);

protected:

    static const char* ids_[];

public:

    IServerClient() { }
    virtual ~IServerClient() { }

    typedef IServerClient_ptr _ptr_type;
    typedef IServerClient_var _var_type;

    static inline IServerClient_ptr
    _duplicate(IServerClient_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline IServerClient_ptr
    _nil()
    {
        return 0;
    }

    static IServerClient_ptr _narrow(::CORBA::Object_ptr);
    static IServerClient_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static IServerClient_ptr _narrow(::CORBA::AbstractBase_ptr);
    static IServerClient_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:IServerClient/Connect:1.0
    //
    virtual ::DomainData::Address* Connect(const ::DomainData::Address& server,
                                           ::DomainData::Mode m,
                                           const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/Disconnect:1.0
    //
    virtual void Disconnect(const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/Register:1.0
    //
    virtual ::DomainData::User* Register(const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/SendMessage:1.0
    //
    virtual void SendMessage(const ::DomainData::User& ssender,
                             const ::DomainData::User& receiver,
                             const ::DomainData::Message& msg) = 0;

    //
    // IDL:IServerClient/CheckClientStatus:1.0
    //
    virtual ::DomainData::Enability CheckClientStatus(const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/GetPipeHolder:1.0
    //
    virtual ::DomainData::User* GetPipeHolder(const ::DomainData::User& receiver) = 0;

    //
    // IDL:IServerClient/GetUserAddressByName:1.0
    //
    virtual ::DomainData::Address* GetUserAddressByName(const ::DomainData::User& usr) = 0;
};

//
// IDL:IServerClient:1.0
//
class OBProxy_IServerClient : virtual public ::IServerClient,
                              virtual public OBCORBA::Object
{
    OBProxy_IServerClient(const OBProxy_IServerClient&);
    void operator=(const OBProxy_IServerClient&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    OBProxy_IServerClient() { }
    virtual ~OBProxy_IServerClient() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:IServerClient/Connect:1.0
    //
    ::DomainData::Address* Connect(const ::DomainData::Address& server,
                                   ::DomainData::Mode m,
                                   const ::DomainData::User& usr);

    //
    // IDL:IServerClient/Disconnect:1.0
    //
    void Disconnect(const ::DomainData::User& usr);

    //
    // IDL:IServerClient/Register:1.0
    //
    ::DomainData::User* Register(const ::DomainData::User& usr);

    //
    // IDL:IServerClient/SendMessage:1.0
    //
    void SendMessage(const ::DomainData::User& ssender,
                     const ::DomainData::User& receiver,
                     const ::DomainData::Message& msg);

    //
    // IDL:IServerClient/CheckClientStatus:1.0
    //
    ::DomainData::Enability CheckClientStatus(const ::DomainData::User& usr);

    //
    // IDL:IServerClient/GetPipeHolder:1.0
    //
    ::DomainData::User* GetPipeHolder(const ::DomainData::User& receiver);

    //
    // IDL:IServerClient/GetUserAddressByName:1.0
    //
    ::DomainData::Address* GetUserAddressByName(const ::DomainData::User& usr);
};

//
// IDL:IServerClient:1.0
//
class OBStubImpl_IServerClient : virtual public OB::StubImplBase
{
    OBStubImpl_IServerClient(const OBStubImpl_IServerClient&);
    void operator=(const OBStubImpl_IServerClient&);

protected:

    OBStubImpl_IServerClient() { }

public:

    static inline OBStubImpl_IServerClient_ptr
    _duplicate(OBStubImpl_IServerClient_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline OBStubImpl_IServerClient_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:IServerClient/Connect:1.0
    //
    virtual ::DomainData::Address* Connect(const ::DomainData::Address& server,
                                           ::DomainData::Mode m,
                                           const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/Disconnect:1.0
    //
    virtual void Disconnect(const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/Register:1.0
    //
    virtual ::DomainData::User* Register(const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/SendMessage:1.0
    //
    virtual void SendMessage(const ::DomainData::User& ssender,
                             const ::DomainData::User& receiver,
                             const ::DomainData::Message& msg) = 0;

    //
    // IDL:IServerClient/CheckClientStatus:1.0
    //
    virtual ::DomainData::Enability CheckClientStatus(const ::DomainData::User& usr) = 0;

    //
    // IDL:IServerClient/GetPipeHolder:1.0
    //
    virtual ::DomainData::User* GetPipeHolder(const ::DomainData::User& receiver) = 0;

    //
    // IDL:IServerClient/GetUserAddressByName:1.0
    //
    virtual ::DomainData::Address* GetUserAddressByName(const ::DomainData::User& usr) = 0;
};

//
// IDL:IServerClient:1.0
//
class OBMarshalStubImpl_IServerClient : 
    virtual public OBStubImpl_IServerClient,
    virtual public OB::MarshalStubImpl
{
    OBMarshalStubImpl_IServerClient(const OBMarshalStubImpl_IServerClient&);
    void operator=(const OBMarshalStubImpl_IServerClient&);

protected:

    OBMarshalStubImpl_IServerClient() { }
    friend class OBProxy_IServerClient;

public:

    //
    // IDL:IServerClient/Connect:1.0
    //
    virtual ::DomainData::Address* Connect(const ::DomainData::Address& server,
                                           ::DomainData::Mode m,
                                           const ::DomainData::User& usr);

    //
    // IDL:IServerClient/Disconnect:1.0
    //
    virtual void Disconnect(const ::DomainData::User& usr);

    //
    // IDL:IServerClient/Register:1.0
    //
    virtual ::DomainData::User* Register(const ::DomainData::User& usr);

    //
    // IDL:IServerClient/SendMessage:1.0
    //
    virtual void SendMessage(const ::DomainData::User& ssender,
                             const ::DomainData::User& receiver,
                             const ::DomainData::Message& msg);

    //
    // IDL:IServerClient/CheckClientStatus:1.0
    //
    virtual ::DomainData::Enability CheckClientStatus(const ::DomainData::User& usr);

    //
    // IDL:IServerClient/GetPipeHolder:1.0
    //
    virtual ::DomainData::User* GetPipeHolder(const ::DomainData::User& receiver);

    //
    // IDL:IServerClient/GetUserAddressByName:1.0
    //
    virtual ::DomainData::Address* GetUserAddressByName(const ::DomainData::User& usr);
};

//
// IDL:IServerClient:1.0
//
namespace CORBA
{

inline void
release(::IServerClient_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::IServerClient_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_IServerClient_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_IServerClient_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, IServerClient_ptr*);
void operator<<=(::CORBA::Any&, IServerClient_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, IServerClient_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, IServerClient_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, IServerClient_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, IServerClient_ptr& val)
{
    return any.in() >>= val;
}

#endif

// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************
// Version: 4.3.3


///
/// @author	Mateusz Ko³odziejczyk
/// @date	06.01.2009
///
/// @brief	Wygenerowany na podstawie pliku IDLa
///
/// Znajduja sie tutaj klasy: IServerServer, IServerClient a takze definicje struktur:
/// Message, Address, File, Enability, User i enum: Active
///

#ifndef ___ServerInterfaces_h__
#define ___ServerInterfaces_h__

#include "OB/CORBA.h"

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030300L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace DomainData
{

} // End of namespace DomainData

namespace ServerInterfaces
{

class IServerServer;
typedef IServerServer* IServerServer_ptr;
typedef IServerServer* IServerServerRef;

extern OB::TypeCodeConst _tc_IServerServer;

class IServerClient;
typedef IServerClient* IServerClient_ptr;
typedef IServerClient* IServerClientRef;

extern OB::TypeCodeConst _tc_IServerClient;

} // End of namespace ServerInterfaces

void OBDuplicate(ServerInterfaces::IServerServer_ptr);
void OBRelease(ServerInterfaces::IServerServer_ptr);

void OBMarshal(ServerInterfaces::IServerServer_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(ServerInterfaces::IServerServer_ptr&, OB::InputStreamImpl*);

void OBDuplicate(ServerInterfaces::IServerClient_ptr);
void OBRelease(ServerInterfaces::IServerClient_ptr);

void OBMarshal(ServerInterfaces::IServerClient_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(ServerInterfaces::IServerClient_ptr&, OB::InputStreamImpl*);

namespace DomainData
{

} // End of namespace DomainData

namespace ServerInterfaces
{

typedef OB::ObjVar< IServerServer > IServerServer_var;
typedef OB::ObjOut< IServerServer > IServerServer_out;

typedef OB::ObjVar< IServerClient > IServerClient_var;
typedef OB::ObjOut< IServerClient > IServerClient_out;

} // End of namespace ServerInterfaces

namespace OBStubImpl_DomainData
{

} // End of namespace OBStubImpl_DomainData

namespace OBStubImpl_ServerInterfaces
{

class IServerServer;
typedef IServerServer* IServerServer_ptr;

class IServerClient;
typedef IServerClient* IServerClient_ptr;

} // End of namespace OBStubImpl_ServerInterfaces

void OBDuplicate(OBStubImpl_ServerInterfaces::IServerServer_ptr);
void OBRelease(OBStubImpl_ServerInterfaces::IServerServer_ptr);

void OBDuplicate(OBStubImpl_ServerInterfaces::IServerClient_ptr);
void OBRelease(OBStubImpl_ServerInterfaces::IServerClient_ptr);

namespace OBStubImpl_DomainData
{

} // End of namespace OBStubImpl_DomainData

namespace OBStubImpl_ServerInterfaces
{

typedef OB::ObjVar< IServerServer > IServerServer_var;

typedef OB::ObjVar< IServerClient > IServerClient_var;

} // End of namespace OBStubImpl_ServerInterfaces

//
// IDL:DomainData:1.0
//
namespace DomainData
{

//
// IDL:DomainData/Address:1.0
//
struct Address;
typedef OB::VarVar< Address > Address_var;
typedef OB::VarOut< Address > Address_out;

struct Address
{
    Address() { }
    Address(const Address&);
    Address& operator=(const Address&);

    typedef Address_var _var_type;

    OB::StrForStruct name;
    OB::StrForStruct localization;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(Address&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Address;

//
// IDL:DomainData/Message:1.0
//
struct Message;
typedef OB::VarVar< Message > Message_var;
typedef OB::VarOut< Message > Message_out;

struct Message
{
    Message() { }
    Message(const Message&);
    Message& operator=(const Message&);

    typedef Message_var _var_type;

    OB::StrForStruct content;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(Message&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Message;

//
// IDL:DomainData/File:1.0
//
struct File;
typedef OB::VarVar< File > File_var;
typedef OB::VarOut< File > File_out;

struct File
{
    File() { }
    File(const File&);
    File& operator=(const File&);

    typedef File_var _var_type;

    OB::StrForStruct path;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(File&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_File;

//
// IDL:DomainData/Mode:1.0
//
enum Mode
{
    passiv,
    active
};

typedef Mode& Mode_out;

extern OB::TypeCodeConst _tc_Mode;

//
// IDL:DomainData/Enability:1.0
//
struct Enability;
typedef OB::FixVar< Enability > Enability_var;
typedef Enability& Enability_out;

struct Enability
{
    typedef Enability_var _var_type;

    ::CORBA::Boolean status;
    Mode mode_;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(Enability&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Enability;

//
// IDL:DomainData/User:1.0
//
struct User;
typedef OB::VarVar< User > User_var;
typedef OB::VarOut< User > User_out;

struct User
{
#ifdef OB_CLEAR_MEM
    User();
#else
    User() { }
#endif
    User(const User&);
    User& operator=(const User&);

    typedef User_var _var_type;

    OB::StrForStruct name;
    ::CORBA::Long number;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(User&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_User;

} // End of namespace DomainData

//
// IDL:ServerInterfaces:1.0
//
namespace ServerInterfaces
{

//
// IDL:ServerInterfaces/AddressesList:1.0
//
class OBUnique_AddressesList { };

typedef OB::VarSeq< ::DomainData::Address, OBUnique_AddressesList > AddressesList;
typedef OB::SeqVar< OB::VarSeq< ::DomainData::Address, OBUnique_AddressesList > > AddressesList_var;
typedef OB::SeqOut< OB::VarSeq< ::DomainData::Address, OBUnique_AddressesList > > AddressesList_out;
extern OB::TypeCodeConst _tc_AddressesList;

struct OBInfo_AddressesList : public OB::ConstructedInfo
{
    OBInfo_AddressesList() { }

    virtual void free(void* p) const
    {
        delete (AddressesList*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new AddressesList(*(const AddressesList*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:ServerInterfaces/IServerServer:1.0
//
class IServerServer : virtual public ::CORBA::Object
{
    IServerServer(const IServerServer&);
    void operator=(const IServerServer&);

protected:

    static const char* ids_[];

public:

    IServerServer() { }
    virtual ~IServerServer() { }

    typedef IServerServer_ptr _ptr_type;
    typedef IServerServer_var _var_type;

    static inline IServerServer_ptr
    _duplicate(IServerServer_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline IServerServer_ptr
    _nil()
    {
        return 0;
    }

    static IServerServer_ptr _narrow(::CORBA::Object_ptr);
    static IServerServer_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static IServerServer_ptr _narrow(::CORBA::AbstractBase_ptr);
    static IServerServer_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:ServerInterfaces/IServerServer/Join:1.0
    //
    virtual AddressesList* Join() = 0;

    //
    // IDL:ServerInterfaces/IServerServer/Unjoin:1.0
    //
    virtual void Unjoin() = 0;

    //
    // IDL:ServerInterfaces/IServerServer/AddServer:1.0
    //
    virtual void AddServer(const ::DomainData::Address& serverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/RemoveServer:1.0
    //
    virtual void RemoveServer(const ::DomainData::Address& serverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/PassMessage:1.0
    //
    virtual void PassMessage(const ::DomainData::Message& msg,
                             const ::DomainData::Address& senderAddress,
                             const ::DomainData::Address& receiverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/PassCreatePipeRequest:1.0
    //
    virtual void PassCreatePipeRequest(const ::DomainData::Address& pipeHolderAddress,
                                       const ::DomainData::Address& senderAddress,
                                       const ::DomainData::Address& receiverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/ClientStatusChanged:1.0
    //
    virtual void ClientStatusChanged(const ::DomainData::Address& clientAddress,
                                     const ::DomainData::Enability& en) = 0;
};

//
// IDL:ServerInterfaces/IServerClient:1.0
//
class IServerClient : virtual public ::CORBA::Object
{
    IServerClient(const IServerClient&);
    void operator=(const IServerClient&);

protected:

    static const char* ids_[];

public:

    IServerClient() { }
    virtual ~IServerClient() { }

    typedef IServerClient_ptr _ptr_type;
    typedef IServerClient_var _var_type;

    static inline IServerClient_ptr
    _duplicate(IServerClient_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline IServerClient_ptr
    _nil()
    {
        return 0;
    }

    static IServerClient_ptr _narrow(::CORBA::Object_ptr);
    static IServerClient_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static IServerClient_ptr _narrow(::CORBA::AbstractBase_ptr);
    static IServerClient_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:ServerInterfaces/IServerClient/Connect:1.0
    //
    virtual ::DomainData::Address* Connect(::DomainData::Mode m,
                                           const ::DomainData::User& usr) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/Disconnect:1.0
    //
    virtual void Disconnect() = 0;

    //
    // IDL:ServerInterfaces/IServerClient/Register:1.0
    //
    virtual ::DomainData::User* Register(const ::DomainData::User& usr) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/SendMessage:1.0
    //
    virtual void SendMessage(const ::DomainData::Address& receiverAddress,
                             const ::DomainData::Message& msg) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/CheckClientStatus:1.0
    //
    virtual ::DomainData::Enability CheckClientStatus(const ::DomainData::Address& clientAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/GetPipeHolder:1.0
    //
    virtual ::DomainData::Address* GetPipeHolder(const ::DomainData::Address& receiverAddress) = 0;
};

} // End of namespace ServerInterfaces

//
// IDL:DomainData:1.0
//
namespace OBProxy_DomainData
{

} // End of namespace OBProxy_DomainData

//
// IDL:ServerInterfaces:1.0
//
namespace OBProxy_ServerInterfaces
{

//
// IDL:ServerInterfaces/IServerServer:1.0
//
class IServerServer : virtual public ::ServerInterfaces::IServerServer,
                      virtual public OBCORBA::Object
{
    IServerServer(const IServerServer&);
    void operator=(const IServerServer&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    IServerServer() { }
    virtual ~IServerServer() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:ServerInterfaces/IServerServer/Join:1.0
    //
    ::ServerInterfaces::AddressesList* Join();

    //
    // IDL:ServerInterfaces/IServerServer/Unjoin:1.0
    //
    void Unjoin();

    //
    // IDL:ServerInterfaces/IServerServer/AddServer:1.0
    //
    void AddServer(const ::DomainData::Address& serverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/RemoveServer:1.0
    //
    void RemoveServer(const ::DomainData::Address& serverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/PassMessage:1.0
    //
    void PassMessage(const ::DomainData::Message& msg,
                     const ::DomainData::Address& senderAddress,
                     const ::DomainData::Address& receiverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/PassCreatePipeRequest:1.0
    //
    void PassCreatePipeRequest(const ::DomainData::Address& pipeHolderAddress,
                               const ::DomainData::Address& senderAddress,
                               const ::DomainData::Address& receiverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/ClientStatusChanged:1.0
    //
    void ClientStatusChanged(const ::DomainData::Address& clientAddress,
                             const ::DomainData::Enability& en);
};

//
// IDL:ServerInterfaces/IServerClient:1.0
//
class IServerClient : virtual public ::ServerInterfaces::IServerClient,
                      virtual public OBCORBA::Object
{
    IServerClient(const IServerClient&);
    void operator=(const IServerClient&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    IServerClient() { }
    virtual ~IServerClient() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:ServerInterfaces/IServerClient/Connect:1.0
    //
    ::DomainData::Address* Connect(::DomainData::Mode m,
                                   const ::DomainData::User& usr);

    //
    // IDL:ServerInterfaces/IServerClient/Disconnect:1.0
    //
    void Disconnect();

    //
    // IDL:ServerInterfaces/IServerClient/Register:1.0
    //
    ::DomainData::User* Register(const ::DomainData::User& usr);

    //
    // IDL:ServerInterfaces/IServerClient/SendMessage:1.0
    //
    void SendMessage(const ::DomainData::Address& receiverAddress,
                     const ::DomainData::Message& msg);

    //
    // IDL:ServerInterfaces/IServerClient/CheckClientStatus:1.0
    //
    ::DomainData::Enability CheckClientStatus(const ::DomainData::Address& clientAddress);

    //
    // IDL:ServerInterfaces/IServerClient/GetPipeHolder:1.0
    //
    ::DomainData::Address* GetPipeHolder(const ::DomainData::Address& receiverAddress);
};

} // End of namespace OBProxy_ServerInterfaces

//
// IDL:DomainData:1.0
//
namespace OBStubImpl_DomainData
{

} // End of namespace OBStubImpl_DomainData

//
// IDL:ServerInterfaces:1.0
//
namespace OBStubImpl_ServerInterfaces
{

//
// IDL:ServerInterfaces/IServerServer:1.0
//
class IServerServer : virtual public OB::StubImplBase
{
    IServerServer(const IServerServer&);
    void operator=(const IServerServer&);

protected:

    IServerServer() { }

public:

    static inline IServerServer_ptr
    _duplicate(IServerServer_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline IServerServer_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:ServerInterfaces/IServerServer/Join:1.0
    //
    virtual ::ServerInterfaces::AddressesList* Join() = 0;

    //
    // IDL:ServerInterfaces/IServerServer/Unjoin:1.0
    //
    virtual void Unjoin() = 0;

    //
    // IDL:ServerInterfaces/IServerServer/AddServer:1.0
    //
    virtual void AddServer(const ::DomainData::Address& serverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/RemoveServer:1.0
    //
    virtual void RemoveServer(const ::DomainData::Address& serverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/PassMessage:1.0
    //
    virtual void PassMessage(const ::DomainData::Message& msg,
                             const ::DomainData::Address& senderAddress,
                             const ::DomainData::Address& receiverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/PassCreatePipeRequest:1.0
    //
    virtual void PassCreatePipeRequest(const ::DomainData::Address& pipeHolderAddress,
                                       const ::DomainData::Address& senderAddress,
                                       const ::DomainData::Address& receiverAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerServer/ClientStatusChanged:1.0
    //
    virtual void ClientStatusChanged(const ::DomainData::Address& clientAddress,
                                     const ::DomainData::Enability& en) = 0;
};

//
// IDL:ServerInterfaces/IServerClient:1.0
//
class IServerClient : virtual public OB::StubImplBase
{
    IServerClient(const IServerClient&);
    void operator=(const IServerClient&);

protected:

    IServerClient() { }

public:

    static inline IServerClient_ptr
    _duplicate(IServerClient_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline IServerClient_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:ServerInterfaces/IServerClient/Connect:1.0
    //
    virtual ::DomainData::Address* Connect(::DomainData::Mode m,
                                           const ::DomainData::User& usr) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/Disconnect:1.0
    //
    virtual void Disconnect() = 0;

    //
    // IDL:ServerInterfaces/IServerClient/Register:1.0
    //
    virtual ::DomainData::User* Register(const ::DomainData::User& usr) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/SendMessage:1.0
    //
    virtual void SendMessage(const ::DomainData::Address& receiverAddress,
                             const ::DomainData::Message& msg) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/CheckClientStatus:1.0
    //
    virtual ::DomainData::Enability CheckClientStatus(const ::DomainData::Address& clientAddress) = 0;

    //
    // IDL:ServerInterfaces/IServerClient/GetPipeHolder:1.0
    //
    virtual ::DomainData::Address* GetPipeHolder(const ::DomainData::Address& receiverAddress) = 0;
};

} // End of namespace OBStubImpl_ServerInterfaces

//
// IDL:DomainData:1.0
//
namespace OBMarshalStubImpl_DomainData
{

} // End of namespace OBMarshalStubImpl_DomainData

//
// IDL:ServerInterfaces:1.0
//
namespace OBMarshalStubImpl_ServerInterfaces
{

//
// IDL:ServerInterfaces/IServerServer:1.0
//
class IServerServer : 
    virtual public OBStubImpl_ServerInterfaces::IServerServer,
    virtual public OB::MarshalStubImpl
{
    IServerServer(const IServerServer&);
    void operator=(const IServerServer&);

protected:

    IServerServer() { }
    friend class OBProxy_ServerInterfaces::IServerServer;

public:

    //
    // IDL:ServerInterfaces/IServerServer/Join:1.0
    //
    virtual ::ServerInterfaces::AddressesList* Join();

    //
    // IDL:ServerInterfaces/IServerServer/Unjoin:1.0
    //
    virtual void Unjoin();

    //
    // IDL:ServerInterfaces/IServerServer/AddServer:1.0
    //
    virtual void AddServer(const ::DomainData::Address& serverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/RemoveServer:1.0
    //
    virtual void RemoveServer(const ::DomainData::Address& serverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/PassMessage:1.0
    //
    virtual void PassMessage(const ::DomainData::Message& msg,
                             const ::DomainData::Address& senderAddress,
                             const ::DomainData::Address& receiverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/PassCreatePipeRequest:1.0
    //
    virtual void PassCreatePipeRequest(const ::DomainData::Address& pipeHolderAddress,
                                       const ::DomainData::Address& senderAddress,
                                       const ::DomainData::Address& receiverAddress);

    //
    // IDL:ServerInterfaces/IServerServer/ClientStatusChanged:1.0
    //
    virtual void ClientStatusChanged(const ::DomainData::Address& clientAddress,
                                     const ::DomainData::Enability& en);
};

//
// IDL:ServerInterfaces/IServerClient:1.0
//
class IServerClient : 
    virtual public OBStubImpl_ServerInterfaces::IServerClient,
    virtual public OB::MarshalStubImpl
{
    IServerClient(const IServerClient&);
    void operator=(const IServerClient&);

protected:

    IServerClient() { }
    friend class OBProxy_ServerInterfaces::IServerClient;

public:

    //
    // IDL:ServerInterfaces/IServerClient/Connect:1.0
    //
    virtual ::DomainData::Address* Connect(::DomainData::Mode m,
                                           const ::DomainData::User& usr);

    //
    // IDL:ServerInterfaces/IServerClient/Disconnect:1.0
    //
    virtual void Disconnect();

    //
    // IDL:ServerInterfaces/IServerClient/Register:1.0
    //
    virtual ::DomainData::User* Register(const ::DomainData::User& usr);

    //
    // IDL:ServerInterfaces/IServerClient/SendMessage:1.0
    //
    virtual void SendMessage(const ::DomainData::Address& receiverAddress,
                             const ::DomainData::Message& msg);

    //
    // IDL:ServerInterfaces/IServerClient/CheckClientStatus:1.0
    //
    virtual ::DomainData::Enability CheckClientStatus(const ::DomainData::Address& clientAddress);

    //
    // IDL:ServerInterfaces/IServerClient/GetPipeHolder:1.0
    //
    virtual ::DomainData::Address* GetPipeHolder(const ::DomainData::Address& receiverAddress);
};

} // End of namespace OBMarshalStubImpl_ServerInterfaces

//
// IDL:DomainData:1.0
//
namespace OBV_DomainData
{

} // End of namespace OBV_DomainData

//
// IDL:ServerInterfaces:1.0
//
namespace OBV_ServerInterfaces
{

} // End of namespace OBV_ServerInterfaces

//
// IDL:DomainData/Address:1.0
//
void operator<<=(::CORBA::Any&, DomainData::Address*);
void operator<<=(::CORBA::Any&, const DomainData::Address&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const DomainData::Address*&);

inline void
operator<<=(::CORBA::Any_var& any, DomainData::Address* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const DomainData::Address& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const DomainData::Address*& val)
{
    return any.in() >>= val;
}

//
// IDL:DomainData/Message:1.0
//
void operator<<=(::CORBA::Any&, DomainData::Message*);
void operator<<=(::CORBA::Any&, const DomainData::Message&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const DomainData::Message*&);

inline void
operator<<=(::CORBA::Any_var& any, DomainData::Message* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const DomainData::Message& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const DomainData::Message*& val)
{
    return any.in() >>= val;
}

//
// IDL:DomainData/File:1.0
//
void operator<<=(::CORBA::Any&, DomainData::File*);
void operator<<=(::CORBA::Any&, const DomainData::File&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const DomainData::File*&);

inline void
operator<<=(::CORBA::Any_var& any, DomainData::File* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const DomainData::File& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const DomainData::File*& val)
{
    return any.in() >>= val;
}

//
// IDL:DomainData/Mode:1.0
//
void operator<<=(::CORBA::Any&, DomainData::Mode);
CORBA::Boolean operator>>=(const ::CORBA::Any&, DomainData::Mode&);

inline void
operator<<=(::CORBA::Any_var& any, DomainData::Mode val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, DomainData::Mode& val)
{
    return any.in() >>= val;
}

//
// IDL:DomainData/Enability:1.0
//
void operator<<=(::CORBA::Any&, DomainData::Enability*);
void operator<<=(::CORBA::Any&, const DomainData::Enability&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const DomainData::Enability*&);

inline void
operator<<=(::CORBA::Any_var& any, DomainData::Enability* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const DomainData::Enability& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const DomainData::Enability*& val)
{
    return any.in() >>= val;
}

//
// IDL:DomainData/User:1.0
//
void operator<<=(::CORBA::Any&, DomainData::User*);
void operator<<=(::CORBA::Any&, const DomainData::User&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const DomainData::User*&);

inline void
operator<<=(::CORBA::Any_var& any, DomainData::User* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const DomainData::User& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const DomainData::User*& val)
{
    return any.in() >>= val;
}

//
// IDL:ServerInterfaces/AddressesList:1.0
//
void operator<<=(::CORBA::Any&, ServerInterfaces::AddressesList*);
void operator<<=(::CORBA::Any&, const ServerInterfaces::AddressesList&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const ServerInterfaces::AddressesList*&);

inline void
operator<<=(::CORBA::Any_var& any, ServerInterfaces::AddressesList* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const ServerInterfaces::AddressesList& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const ServerInterfaces::AddressesList*& val)
{
    return any.in() >>= val;
}

//
// IDL:ServerInterfaces/IServerServer:1.0
//
namespace CORBA
{

inline void
release(::ServerInterfaces::IServerServer_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::ServerInterfaces::IServerServer_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_ServerInterfaces::IServerServer_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_ServerInterfaces::IServerServer_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, ServerInterfaces::IServerServer_ptr*);
void operator<<=(::CORBA::Any&, ServerInterfaces::IServerServer_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, ServerInterfaces::IServerServer_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, ServerInterfaces::IServerServer_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, ServerInterfaces::IServerServer_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, ServerInterfaces::IServerServer_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:ServerInterfaces/IServerClient:1.0
//
namespace CORBA
{

inline void
release(::ServerInterfaces::IServerClient_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::ServerInterfaces::IServerClient_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_ServerInterfaces::IServerClient_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_ServerInterfaces::IServerClient_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, ServerInterfaces::IServerClient_ptr*);
void operator<<=(::CORBA::Any&, ServerInterfaces::IServerClient_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, ServerInterfaces::IServerClient_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, ServerInterfaces::IServerClient_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, ServerInterfaces::IServerClient_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, ServerInterfaces::IServerClient_ptr& val)
{
    return any.in() >>= val;
}

#endif

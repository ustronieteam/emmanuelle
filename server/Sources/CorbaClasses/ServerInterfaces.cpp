// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.3

#include <OB/CORBAClient.h>
#include <ServerInterfaces.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030300L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace DomainData
{

::OB::TypeCodeConst _tc_Address(
"010000000f0000006400000001fb59001b00000049444c3a446f6d61696e446174612f4164647"
"26573733a312e30000008000000416464726573730002000000050000006e616d650079000012"
"000000000000000d0000006c6f63616c697a6174696f6e000001001200000000000000"
);

::OB::TypeCodeConst _tc_Message(
"010000000f0000004800000001fb59001b00000049444c3a446f6d61696e446174612f4d65737"
"36167653a312e300000080000004d657373616765000100000008000000636f6e74656e740012"
"00000000000000"
);

::OB::TypeCodeConst _tc_File(
"010000000f0000004400000001fb59001800000049444c3a446f6d61696e446174612f46696c6"
"53a312e30000500000046696c6500657373010000000500000070617468006f6e741200000000"
"000000"
);

::OB::TypeCodeConst _tc_Mode(
"01000000110000004700000001fb59001800000049444c3a446f6d61696e446174612f4d6f646"
"53a312e3000050000004d6f646500657373020000000700000070617373697600740700000061"
"637469766500"
);

::OB::TypeCodeConst _tc_Enability(
"010000000f000000a700000001fb59001d00000049444c3a446f6d61696e446174612f456e616"
"2696c6974793a312e30006f64650a000000456e6162696c697479007373020000000700000073"
"7461747573000008000000060000006d6f64655f006f6e1100000047000000010000001800000"
"049444c3a446f6d61696e446174612f4d6f64653a312e3000050000004d6f646500fb59000200"
"00000700000070617373697600000700000061637469766500"
);

::OB::TypeCodeConst _tc_User(
"010000000f0000005400000001fb59001800000049444c3a446f6d61696e446174612f5573657"
"23a312e300005000000557365720000000002000000050000006e616d65000000001200000000"
"000000070000006e756d626572000003000000"
);

} // End of namespace DomainData

namespace ServerInterfaces
{

::OB::TypeCodeConst _tc_AddressesList(
"0100000015000000c000000001fb59002700000049444c3a536572766572496e7465726661636"
"5732f4164647265737365734c6973743a312e3000000e0000004164647265737365734c697374"
"0000001300000074000000017200000f00000064000000010000001b00000049444c3a446f6d6"
"1696e446174612f416464726573733a312e30003a080000004164647265737300020000000500"
"00006e616d650002917c12000000000000000d0000006c6f63616c697a6174696f6e000039001"
"20000000000000000000000"
);

::OB::TypeCodeConst _tc_IServerServer(
"010000000e0000004200000001fb59002700000049444c3a536572766572496e7465726661636"
"5732f495365727665725365727665723a312e3000000e00000049536572766572536572766572"
"00"
);

::OB::TypeCodeConst _tc_IServerClient(
"010000000e0000004200000001fb59002700000049444c3a536572766572496e7465726661636"
"5732f49536572766572436c69656e743a312e3000000e00000049536572766572436c69656e74"
"00"
);

} // End of namespace ServerInterfaces

//
// IDL:DomainData/Address:1.0
//
DomainData::Address::Address(const Address& _ob_a)
    : name(_ob_a.name),
      localization(_ob_a.localization)
{
}

DomainData::Address&
DomainData::Address::operator=(const Address& _ob_a)
{
    if(this != &_ob_a)
    {
        name = _ob_a.name;
        localization = _ob_a.localization;
    }
    return *this;
}

void
DomainData::Address::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_string(name);
    _ob_out -> write_string(localization);
}

void
DomainData::Address::_OB_unmarshal(Address& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.name = _ob_in -> read_string();
    _ob_v.localization = _ob_in -> read_string();
}

void
operator<<=(::CORBA::Any& any, DomainData::Address* v)
{
    static const OB::Info< DomainData::Address > info;
    any.replace(DomainData::_tc_Address, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const DomainData::Address& v)
{
    any <<= new DomainData::Address(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const DomainData::Address*& v)
{
    if(any.check_type(DomainData::_tc_Address))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            DomainData::Address* val = new DomainData::Address;
            DomainData::Address::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (DomainData::Address*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:DomainData/Message:1.0
//
DomainData::Message::Message(const Message& _ob_a)
    : content(_ob_a.content)
{
}

DomainData::Message&
DomainData::Message::operator=(const Message& _ob_a)
{
    if(this != &_ob_a)
    {
        content = _ob_a.content;
    }
    return *this;
}

void
DomainData::Message::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_string(content);
}

void
DomainData::Message::_OB_unmarshal(Message& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.content = _ob_in -> read_string();
}

void
operator<<=(::CORBA::Any& any, DomainData::Message* v)
{
    static const OB::Info< DomainData::Message > info;
    any.replace(DomainData::_tc_Message, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const DomainData::Message& v)
{
    any <<= new DomainData::Message(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const DomainData::Message*& v)
{
    if(any.check_type(DomainData::_tc_Message))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            DomainData::Message* val = new DomainData::Message;
            DomainData::Message::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (DomainData::Message*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:DomainData/File:1.0
//
DomainData::File::File(const File& _ob_a)
    : path(_ob_a.path)
{
}

DomainData::File&
DomainData::File::operator=(const File& _ob_a)
{
    if(this != &_ob_a)
    {
        path = _ob_a.path;
    }
    return *this;
}

void
DomainData::File::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_string(path);
}

void
DomainData::File::_OB_unmarshal(File& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.path = _ob_in -> read_string();
}

void
operator<<=(::CORBA::Any& any, DomainData::File* v)
{
    static const OB::Info< DomainData::File > info;
    any.replace(DomainData::_tc_File, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const DomainData::File& v)
{
    any <<= new DomainData::File(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const DomainData::File*& v)
{
    if(any.check_type(DomainData::_tc_File))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            DomainData::File* val = new DomainData::File;
            DomainData::File::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (DomainData::File*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:DomainData/Mode:1.0
//
void
operator<<=(::CORBA::Any& any, DomainData::Mode v)
{
    any.replace(DomainData::_tc_Mode, new ::CORBA::ULong((::CORBA::ULong)v), true);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, DomainData::Mode& v)
{
    if(any.check_type(DomainData::_tc_Mode))
    {
        v = (DomainData::Mode)(*(::CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// IDL:DomainData/Enability:1.0
//
void
DomainData::Enability::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_boolean(status);
    _ob_out -> write_ulong((::CORBA::ULong)mode_);
}

void
DomainData::Enability::_OB_unmarshal(Enability& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.status = _ob_in -> read_boolean();
    _ob_v.mode_ = (Mode)_ob_in -> read_ulong();
}

void
operator<<=(::CORBA::Any& any, DomainData::Enability* v)
{
    static const OB::Info< DomainData::Enability > info;
    any.replace(DomainData::_tc_Enability, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const DomainData::Enability& v)
{
    any <<= new DomainData::Enability(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const DomainData::Enability*& v)
{
    if(any.check_type(DomainData::_tc_Enability))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            DomainData::Enability* val = new DomainData::Enability;
            DomainData::Enability::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (DomainData::Enability*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:DomainData/User:1.0
//
#ifdef OB_CLEAR_MEM
DomainData::User::User()
{
    memset(&number, 0, sizeof(number));
}
#endif

DomainData::User::User(const User& _ob_a)
    : name(_ob_a.name),
      number(_ob_a.number)
{
}

DomainData::User&
DomainData::User::operator=(const User& _ob_a)
{
    if(this != &_ob_a)
    {
        name = _ob_a.name;
        number = _ob_a.number;
    }
    return *this;
}

void
DomainData::User::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_string(name);
    _ob_out -> write_long(number);
}

void
DomainData::User::_OB_unmarshal(User& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.name = _ob_in -> read_string();
    _ob_v.number = _ob_in -> read_long();
}

void
operator<<=(::CORBA::Any& any, DomainData::User* v)
{
    static const OB::Info< DomainData::User > info;
    any.replace(DomainData::_tc_User, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const DomainData::User& v)
{
    any <<= new DomainData::User(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const DomainData::User*& v)
{
    if(any.check_type(DomainData::_tc_User))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            DomainData::User* val = new DomainData::User;
            DomainData::User::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (DomainData::User*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:ServerInterfaces/AddressesList:1.0
//
void
ServerInterfaces::OBInfo_AddressesList::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::ServerInterfaces::AddressesList& _ob_seq = *(const ::ServerInterfaces::AddressesList*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::DomainData::Address const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
ServerInterfaces::OBInfo_AddressesList::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::ServerInterfaces::AddressesList& _ob_seq = *(::ServerInterfaces::AddressesList*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::DomainData::Address * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::DomainData::Address::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, ServerInterfaces::AddressesList* v)
{
    static const ServerInterfaces::OBInfo_AddressesList info;
    any.replace(ServerInterfaces::_tc_AddressesList, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const ServerInterfaces::AddressesList& v)
{
    any <<= new ServerInterfaces::AddressesList(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const ServerInterfaces::AddressesList*& v)
{
    if(any.check_type(ServerInterfaces::_tc_AddressesList))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            ServerInterfaces::AddressesList* val = new ServerInterfaces::AddressesList;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::DomainData::Address * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::DomainData::Address::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (ServerInterfaces::AddressesList*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:ServerInterfaces/IServerServer:1.0
//
const char* ServerInterfaces::IServerServer::ids_[] =
{
    "IDL:ServerInterfaces/IServerServer:1.0",
    0
};

void
OBDuplicate(ServerInterfaces::IServerServer_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(ServerInterfaces::IServerServer_ptr p)
{
    if(p)
        p -> _remove_ref();
}

ServerInterfaces::IServerServer_ptr
ServerInterfaces::IServerServer::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IServerServer_ptr v = 
            dynamic_cast< IServerServer_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_ServerInterfaces::IServerServer* val = new OBProxy_ServerInterfaces::IServerServer;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

ServerInterfaces::IServerServer_ptr
ServerInterfaces::IServerServer::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IServerServer_ptr v =
            dynamic_cast< IServerServer_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

ServerInterfaces::IServerServer_ptr
ServerInterfaces::IServerServer::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IServerServer_ptr v =
            dynamic_cast< IServerServer_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_ServerInterfaces::IServerServer* val = new OBProxy_ServerInterfaces::IServerServer;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

ServerInterfaces::IServerServer_ptr
ServerInterfaces::IServerServer::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
ServerInterfaces::IServerServer::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(ServerInterfaces::IServerServer_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(ServerInterfaces::IServerServer_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    ServerInterfaces::IServerServer_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_ServerInterfaces::IServerServer* _ob_obj = new OBProxy_ServerInterfaces::IServerServer;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = ServerInterfaces::IServerServer::_nil();
}

void
operator<<=(::CORBA::Any& any, ServerInterfaces::IServerServer_ptr* v)
{
    any.replace(ServerInterfaces::_tc_IServerServer, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, ServerInterfaces::IServerServer_ptr v)
{
    ServerInterfaces::IServerServer_ptr val = ServerInterfaces::IServerServer::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, ServerInterfaces::IServerServer_ptr& v)
{
    if(any.check_type(ServerInterfaces::_tc_IServerServer))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< ServerInterfaces::IServerServer_ptr >(val)))
            {
                OBProxy_ServerInterfaces::IServerServer* obj = new OBProxy_ServerInterfaces::IServerServer;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = ServerInterfaces::IServerServer::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:ServerInterfaces/IServerClient:1.0
//
const char* ServerInterfaces::IServerClient::ids_[] =
{
    "IDL:ServerInterfaces/IServerClient:1.0",
    0
};

void
OBDuplicate(ServerInterfaces::IServerClient_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(ServerInterfaces::IServerClient_ptr p)
{
    if(p)
        p -> _remove_ref();
}

ServerInterfaces::IServerClient_ptr
ServerInterfaces::IServerClient::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IServerClient_ptr v = 
            dynamic_cast< IServerClient_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_ServerInterfaces::IServerClient* val = new OBProxy_ServerInterfaces::IServerClient;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

ServerInterfaces::IServerClient_ptr
ServerInterfaces::IServerClient::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IServerClient_ptr v =
            dynamic_cast< IServerClient_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

ServerInterfaces::IServerClient_ptr
ServerInterfaces::IServerClient::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IServerClient_ptr v =
            dynamic_cast< IServerClient_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_ServerInterfaces::IServerClient* val = new OBProxy_ServerInterfaces::IServerClient;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

ServerInterfaces::IServerClient_ptr
ServerInterfaces::IServerClient::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
ServerInterfaces::IServerClient::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(ServerInterfaces::IServerClient_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(ServerInterfaces::IServerClient_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    ServerInterfaces::IServerClient_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_ServerInterfaces::IServerClient* _ob_obj = new OBProxy_ServerInterfaces::IServerClient;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = ServerInterfaces::IServerClient::_nil();
}

void
operator<<=(::CORBA::Any& any, ServerInterfaces::IServerClient_ptr* v)
{
    any.replace(ServerInterfaces::_tc_IServerClient, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, ServerInterfaces::IServerClient_ptr v)
{
    ServerInterfaces::IServerClient_ptr val = ServerInterfaces::IServerClient::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, ServerInterfaces::IServerClient_ptr& v)
{
    if(any.check_type(ServerInterfaces::_tc_IServerClient))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< ServerInterfaces::IServerClient_ptr >(val)))
            {
                OBProxy_ServerInterfaces::IServerClient* obj = new OBProxy_ServerInterfaces::IServerClient;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = ServerInterfaces::IServerClient::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:ServerInterfaces/IServerServer:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_ServerInterfaces::IServerServer::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_ServerInterfaces::IServerServer;
}

const char**
OBProxy_ServerInterfaces::IServerServer::_OB_ids() const
{
    return ::ServerInterfaces::IServerServer::ids_;
}

//
// IDL:ServerInterfaces/IServerServer/Join:1.0
//
::ServerInterfaces::AddressesList*
OBProxy_ServerInterfaces::IServerServer::Join()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> Join();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/Unjoin:1.0
//
void
OBProxy_ServerInterfaces::IServerServer::Unjoin()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> Unjoin();
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/AddServer:1.0
//
void
OBProxy_ServerInterfaces::IServerServer::AddServer(const ::DomainData::Address& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> AddServer(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/RemoveServer:1.0
//
void
OBProxy_ServerInterfaces::IServerServer::RemoveServer(const ::DomainData::Address& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> RemoveServer(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/PassMessage:1.0
//
void
OBProxy_ServerInterfaces::IServerServer::PassMessage(const ::DomainData::Message& _ob_a0,
                                                     const ::DomainData::Address& _ob_a1,
                                                     const ::DomainData::Address& _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> PassMessage(_ob_a0, _ob_a1, _ob_a2);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/PassCreatePipeRequest:1.0
//
void
OBProxy_ServerInterfaces::IServerServer::PassCreatePipeRequest(const ::DomainData::Address& _ob_a0,
                                                               const ::DomainData::Address& _ob_a1,
                                                               const ::DomainData::Address& _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> PassCreatePipeRequest(_ob_a0, _ob_a1, _ob_a2);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/ClientStatusChanged:1.0
//
void
OBProxy_ServerInterfaces::IServerServer::ClientStatusChanged(const ::DomainData::Address& _ob_a0,
                                                             const ::DomainData::Enability& _ob_a1)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerServer_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerServer_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> ClientStatusChanged(_ob_a0, _ob_a1);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_ServerInterfaces::IServerClient::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_ServerInterfaces::IServerClient;
}

const char**
OBProxy_ServerInterfaces::IServerClient::_OB_ids() const
{
    return ::ServerInterfaces::IServerClient::ids_;
}

//
// IDL:ServerInterfaces/IServerClient/Connect:1.0
//
::DomainData::Address*
OBProxy_ServerInterfaces::IServerClient::Connect(::DomainData::Mode _ob_a0,
                                                 const ::DomainData::User& _ob_a1)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerClient_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerClient_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> Connect(_ob_a0, _ob_a1);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/Disconnect:1.0
//
void
OBProxy_ServerInterfaces::IServerClient::Disconnect()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerClient_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerClient_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> Disconnect();
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/Register:1.0
//
::DomainData::User*
OBProxy_ServerInterfaces::IServerClient::Register(const ::DomainData::User& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerClient_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerClient_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> Register(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/SendMessage:1.0
//
void
OBProxy_ServerInterfaces::IServerClient::SendMessage(const ::DomainData::Address& _ob_a0,
                                                     const ::DomainData::Message& _ob_a1)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerClient_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerClient_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> SendMessage(_ob_a0, _ob_a1);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/CheckClientStatus:1.0
//
::DomainData::Enability
OBProxy_ServerInterfaces::IServerClient::CheckClientStatus(const ::DomainData::Address& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerClient_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerClient_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> CheckClientStatus(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/GetPipeHolder:1.0
//
::DomainData::Address*
OBProxy_ServerInterfaces::IServerClient::GetPipeHolder(const ::DomainData::Address& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ServerInterfaces::IServerClient_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_ServerInterfaces::IServerClient_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> GetPipeHolder(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer:1.0
//
void
OBDuplicate(OBStubImpl_ServerInterfaces::IServerServer_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_ServerInterfaces::IServerServer_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:ServerInterfaces/IServerClient:1.0
//
void
OBDuplicate(OBStubImpl_ServerInterfaces::IServerClient_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_ServerInterfaces::IServerClient_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:ServerInterfaces/IServerServer/Join:1.0
//
::ServerInterfaces::AddressesList*
OBMarshalStubImpl_ServerInterfaces::IServerServer::Join()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("Join", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::ServerInterfaces::AddressesList_var _ob_r;
                try
                {
                    _ob_r = new ::ServerInterfaces::AddressesList;
                    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
                    _ob_r -> length(_ob_len0);
                    ::DomainData::Address * _ob_buf0 = _ob_r -> get_buffer();
                    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                    {
                        ::DomainData::Address::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/Unjoin:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerServer::Unjoin()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("Unjoin", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/AddServer:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerServer::AddServer(const ::DomainData::Address& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("AddServer", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/RemoveServer:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerServer::RemoveServer(const ::DomainData::Address& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("RemoveServer", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/PassMessage:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerServer::PassMessage(const ::DomainData::Message& _ob_a0,
                                                               const ::DomainData::Address& _ob_a1,
                                                               const ::DomainData::Address& _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("PassMessage", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
                _ob_a1._OB_marshal(_ob_out);
                _ob_a2._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/PassCreatePipeRequest:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerServer::PassCreatePipeRequest(const ::DomainData::Address& _ob_a0,
                                                                         const ::DomainData::Address& _ob_a1,
                                                                         const ::DomainData::Address& _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("PassCreatePipeRequest", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
                _ob_a1._OB_marshal(_ob_out);
                _ob_a2._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerServer/ClientStatusChanged:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerServer::ClientStatusChanged(const ::DomainData::Address& _ob_a0,
                                                                       const ::DomainData::Enability& _ob_a1)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("ClientStatusChanged", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
                _ob_a1._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/Connect:1.0
//
::DomainData::Address*
OBMarshalStubImpl_ServerInterfaces::IServerClient::Connect(::DomainData::Mode _ob_a0,
                                                           const ::DomainData::User& _ob_a1)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("Connect", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_ulong((::CORBA::ULong)_ob_a0);
                _ob_a1._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::DomainData::Address_var _ob_r;
                try
                {
                    _ob_r = new ::DomainData::Address;
                    ::DomainData::Address::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/Disconnect:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerClient::Disconnect()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("Disconnect", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/Register:1.0
//
::DomainData::User*
OBMarshalStubImpl_ServerInterfaces::IServerClient::Register(const ::DomainData::User& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("Register", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::DomainData::User_var _ob_r;
                try
                {
                    _ob_r = new ::DomainData::User;
                    ::DomainData::User::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/SendMessage:1.0
//
void
OBMarshalStubImpl_ServerInterfaces::IServerClient::SendMessage(const ::DomainData::Address& _ob_a0,
                                                               const ::DomainData::Message& _ob_a1)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SendMessage", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
                _ob_a1._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/CheckClientStatus:1.0
//
::DomainData::Enability
OBMarshalStubImpl_ServerInterfaces::IServerClient::CheckClientStatus(const ::DomainData::Address& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("CheckClientStatus", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::DomainData::Enability _ob_r;
                try
                {
                    ::DomainData::Enability::_OB_unmarshal(_ob_r, _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:ServerInterfaces/IServerClient/GetPipeHolder:1.0
//
::DomainData::Address*
OBMarshalStubImpl_ServerInterfaces::IServerClient::GetPipeHolder(const ::DomainData::Address& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("GetPipeHolder", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_a0._OB_marshal(_ob_out);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::DomainData::Address_var _ob_r;
                try
                {
                    _ob_r = new ::DomainData::Address;
                    ::DomainData::Address::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}
